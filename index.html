<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cube Surfer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 24px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="ui">Score: 0</div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';

      const scene = new THREE.Scene();
      const clock = new THREE.Clock();
      let score = 0;
      let gameActive = true;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // In this setup:
      // - The player (yellow cube) is fixed at z = 0.
      // - Obstacles spawn at z = -100 and move in the positive z direction.
      // - The camera is positioned behind the player (positive z) so obstacles appear in front.
      // - The red chase cube is always behind the player (even further positive z).
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 1.5, 0);

      // Create a simple ground/track
      const trackGeometry = new THREE.PlaneGeometry(20, 500);
      const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const track = new THREE.Mesh(trackGeometry, trackMaterial);
      track.rotation.x = -Math.PI / 2;
      // Position the track so it covers the area ahead (negative z)
      track.position.z = -250;
      scene.add(track);

      // Basic lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Define three lanes; lanes indices 0, 1, 2 mapped to x positions
      const lanes = [-4, 0, 4];
      // Start in the middle lane (index 1)
      let currentLane = 1;
      let targetLane = currentLane;
      let isChangingLane = false;

      // Create the player cube (yellow)
      const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
      const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
      const player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.position.set(lanes[currentLane], 1.5, 0);
      player.castShadow = true;
      scene.add(player);

      // Create the red chase cube
      const chaseGeometry = new THREE.BoxGeometry(2, 2, 2);
      const chaseMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff4444,
        emissiveIntensity: 1
      });
      const chaseCube = new THREE.Mesh(chaseGeometry, chaseMaterial);
      // Initially place it behind the player at z = player.z + 20
      chaseCube.position.set(player.position.x, player.position.y + 3, player.position.z + 20);
      chaseCube.castShadow = true;
      scene.add(chaseCube);

      // Obstacles (trains) and spawn control
      let obstacles = [];
      let obstacleSpawnTimer = 0;
      const obstacleSpawnInterval = 2; // seconds

      // Spawn a train obstacle in a random lane
      function spawnTrain() {
        const laneIndex = Math.floor(Math.random() * lanes.length);
        const trainGeometry = new THREE.BoxGeometry(3, 2, 6);
        const trainMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
        const train = new THREE.Mesh(trainGeometry, trainMaterial);
        train.castShadow = true;
        // Spawn ahead of the player (at z = -100)
        train.position.set(lanes[laneIndex], 1.5, -100);
        train.userData.lane = laneIndex;
        obstacles.push(train);
        scene.add(train);
      }

      // Listen for left/right arrow keys to initiate lane changes
      window.addEventListener("keydown", (e) => {
        if (!gameActive || isChangingLane) return;
        if (e.key === "ArrowLeft" && currentLane > 0) {
          targetLane = currentLane - 1;
          isChangingLane = true;
        } else if (e.key === "ArrowRight" && currentLane < lanes.length - 1) {
          targetLane = currentLane + 1;
          isChangingLane = true;
        }
      });

      // Check collisions between player and obstacles using bounding boxes
      function checkCollisions() {
        const playerBox = new THREE.Box3().setFromObject(player);
        for (let obs of obstacles) {
          const obsBox = new THREE.Box3().setFromObject(obs);
          if (playerBox.intersectsBox(obsBox)) {
            return obs;
          }
        }
        return null;
      }

      // Game over: stop the game and show an alert
      function gameOver() {
        gameActive = false;
        alert("Game Over! Score: " + Math.floor(score));
        location.reload();
      }

      // Lane change animation parameters
      const laneChangeSpeed = 10; // units per second

      // Chase effect variables (for side-collisions)
      let chaseTriggered = false;
      let chaseTimer = 0;
      const chaseDuration = 1.0; // seconds

      // Main animation loop
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if (!gameActive) return;

        score += delta * 10;
        document.getElementById("ui").textContent = "Score: " + Math.floor(score);

        // Smooth lane change animation
        if (isChangingLane) {
          const targetX = lanes[targetLane];
          const diff = targetX - player.position.x;
          if (Math.abs(diff) < 0.05) {
            player.position.x = targetX;
            currentLane = targetLane;
            isChangingLane = false;
          } else {
            player.position.x += Math.sign(diff) * laneChangeSpeed * delta;
          }
        }

        // Move obstacles toward the player (increase their z)
        for (let i = obstacles.length - 1; i >= 0; i--) {
          let obs = obstacles[i];
          obs.position.z += 30 * delta;
          // Remove obstacle if it passes the player (z > 10)
          if (obs.position.z > 10) {
            scene.remove(obs);
            obstacles.splice(i, 1);
          }
        }

        // Spawn new obstacles periodically
        obstacleSpawnTimer += delta;
        if (obstacleSpawnTimer > obstacleSpawnInterval) {
          spawnTrain();
          obstacleSpawnTimer = 0;
        }

        // Collision detection
        let collidedObs = checkCollisions();
        if (collidedObs) {
          // If player is in the middle of a lane change and isn't aligned with the obstacle lane,
          // treat it as a side collision:
          if (Math.abs(player.position.x - lanes[collidedObs.userData.lane]) > 0.5 && isChangingLane) {
            // Trigger chase: the red cube will come closer
            chaseTriggered = true;
            chaseTimer = 0;
            // Revert lane change by setting target back to the current lane
            targetLane = currentLane;
            isChangingLane = true;
          } else {
            // Otherwise, it's a frontal collision â†’ game over
            gameOver();
          }
        }

        // Update the chase cube position.
        // In normal state, it stays behind the player at a distance of 20 units.
        // When chaseTriggered, it moves closer to a distance of 5.
        let chaseZ = player.position.z + 20;
        if (chaseTriggered) {
          chaseTimer += delta;
          chaseZ = THREE.MathUtils.lerp(player.position.z + 20, player.position.z + 5, chaseTimer / chaseDuration);
          if (chaseTimer >= chaseDuration) {
            chaseTriggered = false;
          }
        }
        chaseCube.position.set(player.position.x, player.position.y + 3, chaseZ);

        // Camera follows the player: keep the camera behind the player.
        camera.position.x = player.position.x;
        camera.position.z = player.position.z + 10;
        camera.lookAt(player.position);

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
