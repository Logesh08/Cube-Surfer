<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Surfer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">Score: 0</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        let score = 0;
        let gameActive = true;
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Player
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 0.3,
            roughness: 0.4
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.castShadow = true;
        player.position.y = 1.5;
        scene.add(player);

        // Track System
        const track = new THREE.Group();
        const trackWidth = 15;
        const trackHeight = 0.5;
        const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        let trackSegments = [];

        // Generate track with proper proportions
        for(let i = 0; i < 5; i++) {
            const segment = new THREE.Mesh(
                new THREE.BoxGeometry(trackWidth, trackHeight, 20),
                trackMaterial
            );
            segment.position.z = i * -20;
            segment.position.y = -0.25;
            segment.receiveShadow = true;
            track.add(segment);
            trackSegments.push(segment);

            // Add elements as children of the segment
            // Rails
            const railGeometry = new THREE.CylinderGeometry(0.15, 0.15, 20);
            const railMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                metalness: 0.5
            });
            for(let x of [-5.5, 5.5]) {
                const rail = new THREE.Mesh(railGeometry, railMaterial);
                rail.rotation.z = Math.PI/2;
                rail.position.set(x, 0.15, 0);
                segment.add(rail);
            }

            // Lane dividers
            const dividerGeometry = new THREE.BoxGeometry(0.1, 0.2, 20);
            const dividerMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for(let x of [-5, 5]) {
                const divider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                divider.position.set(x, 0.1, 0);
                segment.add(divider);
            }

            // Wooden sleepers
            const sleeperGeometry = new THREE.BoxGeometry(14, 0.1, 0.3);
            const sleeperMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5d432c,
                roughness: 0.8
            });
            for(let z = -9; z <= 9; z += 2) {
                const sleeper = new THREE.Mesh(sleeperGeometry, sleeperMaterial);
                sleeper.position.set(0, -0.05, z);
                segment.add(sleeper);
            }
        }
        scene.add(track);

        // Game state
        let currentLane = 0;
        const lanes = [-4, 0, 4];
        const speed = 0.2;
        let obstacles = [];
        let coins = [];
        let isJumping = false;

        // Controls
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            if (e.key === 'ArrowLeft') currentLane = Math.max(-1, currentLane - 1);
            if (e.key === 'ArrowRight') currentLane = Math.min(1, currentLane + 1);
            if (e.key === 'ArrowUp' && !isJumping) {
                player.position.y = 3;
                isJumping = true;
            }
        });

        // Spawn system
        function spawnTrain() {
            const train = new THREE.Group();
            const carCount = 3;
            const carGeometry = new THREE.BoxGeometry(2, 2, 6);
            const trainMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                metalness: 0.5
            });
            
            for(let i = 0; i < carCount; i++) {
                const car = new THREE.Mesh(carGeometry, trainMaterial);
                car.position.z = i * -6;
                car.castShadow = true;
                train.add(car);
            }
            
            train.position.set(
                lanes[Math.floor(Math.random() * lanes.length)],
                1,
                player.position.z - 100
            );
            scene.add(train);
            obstacles.push(train);
        }

        // Game loop
        function update() {
            if (!gameActive) return;
            
            const delta = clock.getDelta();
            score += delta * 10;

            // Player movement
            player.position.x = THREE.MathUtils.lerp(player.position.x, lanes[currentLane + 1], 0.2);

            // Jump physics
            player.position.y = Math.max(1.5, player.position.y - (isJumping ? 0.2 : 0));
            if (player.position.y === 1.5) isJumping = false;

            // Track movement
            trackSegments.forEach(segment => {
                segment.position.z += speed * 50 * delta;
                if (segment.position.z > 20) {
                    segment.position.z = -80;
                }
            });

            // Train movement
            obstacles.forEach((obstacle, index) => {
                obstacle.position.z += speed * 70 * delta;
                if (obstacle.position.z > 50) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                }
            });

            // Collision detection
            const playerBox = new THREE.Box3().setFromObject(player);
            obstacles.forEach((obstacle, index) => {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    gameOver();
                }
            });

            // Spawning
            if (Math.random() < 0.01) spawnTrain();

            // Camera follow
            camera.position.z = player.position.z + 15;
            camera.position.y = 5;
            camera.lookAt(player.position);

            document.getElementById('ui').textContent = `Score: ${Math.floor(score)}`;
        }

        function gameOver() {
            gameActive = false;
            const overlay = document.createElement('div');
            overlay.style = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                color: white;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-family: Arial;
                text-align: center;
                cursor: pointer;
            `;
            overlay.innerHTML = `
                <h1 style="font-size: 3em; margin: 0">GAME OVER</h1>
                <p style="font-size: 1.5em">Score: ${Math.floor(score)}</p>
                <p>Click to restart</p>
            `;
            document.body.appendChild(overlay);
            overlay.addEventListener('click', () => location.reload());
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>